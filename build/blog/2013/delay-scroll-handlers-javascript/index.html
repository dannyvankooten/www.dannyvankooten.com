<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/styles.css?v=202310222">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="icon" href="/img/favicon.png" type="image/png">
</head>
<body>
<header class="site-header">
    <nav class="container">
        <ul>
            <li class="home"><a href="/" rel="home">Danny van Kooten</a></li>
            <li><a href="/about/">About me</a></li>
            <li><a href="/blog/">Blog</a></li>
            <li><a href="/contact/">Contact</a></li>
        </ul>
    </nav>
</header>
<main>
    <div class="container">

<h1>Delay scroll (and resize) handlers in JavaScript</h1>
    <p>While working on my latest <a href="@/wordpress-plugins.md">WordPress plugin</a> I had to attach a handler to the scroll event of the browser window to determine whether a user scrolled down far enough. While the logic for this is pretty simple, I had to put some thought into handling this the correct way.</p>
<p>Directly attaching a handler to the scroll event is considered bad practice because (depending on the browser) this event can fire <strong>many times within a few milliseconds</strong>. I did some testing and just logging a message in the scroll handler caused my debugger to crash in Internet Explorer. The sames goes for other events like mousemove, keypress and resize.</p>
<pre><code class="language-javascript">$(window).scroll(function() {
	console.log( &quot;Firing!&quot; );
});
</code></pre>
<p>Even the developers at <a href="https://johnresig.com/blog/learning-from-twitter/">Twitter had an issue with scroll event handlers</a> in the past. They were using infinite scroll and attached their handler directly to the scroll event using jQuery. On top of that, they were running jQuery selector queries <em>every time</em> the event handler fired (without caching the results). Enough to make the scrolling experience extremely slow and the site  unresponsive.</p>
<h3>The solution: delaying (or polling) your handlers</h3>
There is a simple solution to this problem: just run your event handlers with a slight delay. This will dramatically cut down on the times your actual callback function is fired. There are multiple ways to go about this but I find a simple timeout the simplest as it requires minimal extra code.
<pre><code class="language-javascript">var timer;

$(window).scroll(function() {
	if(timer) {
		window.clearTimeout(timer);
	}

	timer = window.setTimeout(function() {
		// actual callback
		console.log( &quot;Firing!&quot; );
	}, 100);
});
</code></pre>
<p>This will set a timeout of 100 ms and only then run the actual callback function. If the scroll event is fired again and the 100 ms have not passed yet, it will clear the pending timeout and set a new one. This increased my script performance by about 100% in IE, as my handler was called 10 times less. The same logic can be applied to other events like <em>resize</em> as well.</p>
<h3>Cache your variables</h3>
Another optimization you can do is to move as many code outside the callback function as possible. For the scroll triggered boxes plugin, I had to calculate the window height and the height at which a box should be triggered. These heights do not change between firing handlers so I moved it outside the callback.
<pre><code class="language-javascript">var timer;
var windowHeight = $(window).height();
var triggerHeight = 0.5 * windowHeight;

$(window).scroll(function() {
	if(timer) {
		window.clearTimeout(timer);
	}

	timer = window.setTimeout(function() {

		// this variable changes between callbacks, so we can't cache it
		var y = $(window).scrollTop() + windowHeight;
 
	    if(y &gt; triggerHeight) {
	        // ...
	    }

		
	}, 100);
});
</code></pre>
<p>Hope this saves someone a headache! There are various throttle or debounce plugins available for jQuery that do the same thing but in my opinion you don't really need another dependency for a simple thing as this. As you can see from my code examples, we just added throttling with just 3 or 4 lines of code.</p>

</div>
</main>
<footer class="container site-footer">
    <div class="footer-col mb">
        <ul class="nolist">
            <li><a href="/about/" style="font-weight: bold; text-decoration: none;">About me</a></li>
            <li><a href="/bookmarks/">Bookmarks</a></li>
            <li><a href="/blog/">Blog</a></li>
            <li><a href="/code/">Code</a></li>
            <li><a href="/contact/">Contact me</a></li>
        </ul>
    </div>
    <div class="footer-col mb">
        <ul class="nolist">
            <li><a href="/projects/" style="font-weight: bold; text-decoration: none;">Projects</a></li>
            <li><a href="https://www.mc4wp.com/">Mailchimp for WordPress</a></li>
            <li><a href="https://www.kokoanalytics.com/">Koko Analytics</a></li>
            <li><a href="https://www.htmlformsplugin.com/">HTML Forms plugin</a></li>
        </ul>
    </div>
    <p style="clear:both;">Find me on <a href="https://git.sr.ht/~dvko/" class="icon sourcehut" rel="me nofollow author">sourcehut</a>,
        <a href="https://github.com/dannyvankooten/" class="icon github" rel="me nofollow author">GitHub</a> and <a rel="me" href="https://toot.re/@dvk" class="icon mastodon">Mastodon</a>.
    </p>
    <p>This website is statically built using <a href="https://www.getzola.org/">Zola</a>. You can find <a href="https://git.sr.ht/~dvko/dannyvankooten.com" rel="nofollow">its source code here</a>.</p>
    <p>Pageviews for this site are counted using a standalone spin-off of Koko Analytics, code-named <a href="https://teller.dvk.co/">Teller</a>.</p>
</footer>
<script>
    ((t, cnf) => {
        window[t] = cnf;
        let s = document.createElement('script');
        s.defer = true;
        s.src = [cnf.url, '/assets/', t, '.min.js'].join('');
        document.body.appendChild(s)
    })('teller', {
        url: 'https://teller.dvk.co',
        site: '433ca337-2a49-4391-a340-e3c3bbbb32d3'
    })
</script>
</body>
</html>

